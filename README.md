# Statbase

## Overview

Statbase is an AIâ€‘powered macroeconomic analysis web application built with **Next.js 15** and **TypeScript** using **Material Design 3 (MUI)**.  It leverages daily endâ€‘ofâ€‘day (EOD) price data from FRED (macroeconomic and rates), Alpha Vantage (US equities), and CoinGecko (cryptocurrency) refreshed via a snapshot script (scheduled for 00:05 KST).  Users can ask natural language questions (e.g. "ì• í”Œê³¼ ê¸ˆì˜ ê°€ê²© ì›€ì§ì„ì„ ë¹„êµí•´ì¤˜"), view market summaries (SPY / QQQ / Bitcoin), build custom indices (planned), and generate AIâ€‘assisted reports grounded on recent time series.

This repository provides a preâ€‘configured scaffold tailored for **ë°”ì´ë¸Œì½”ë”©** (vibe coding).  Vibe coding emphasizes naturalâ€‘language prompts, small iterative loops, strict constraints, testâ€‘driven development, and humanâ€‘inâ€‘theâ€‘loop evaluation.  Use this scaffold as a starting point in VSCode Copilot or any LLMâ€‘assisted IDE.

## Features

* **Next.jsÂ 15 + TypeScript** with the new app router.  Pages live under `/app`.
* **MaterialÂ 3 (MUI)** theme with customized tokens in `src/theme` (brand palette, series colors, typography scale, elevation, shape). Theme state is provided via a `ThemeRegistry` wrapper using Emotion cache and MUIâ€™s `ThemeProvider`.
* **AppShell** layout with top app bar and navigation drawer.
* **Dashboard**, **Builder**, **Reports**, **Settings**, and **Style Guide** pages.  Each page integrates **loading** and **error** boundaries for improved UX.
* **Components** for search, summary cards, multiâ€‘line charts (Recharts), report layouts, small talk chat, and an evolving Index Builder.
* **Prompts** folder storing LLM prompt templates and evaluation tasks, used by the streaming report API.
* **Streaming report API**: Server route `app/api/report/route.ts` with data grounding (summaries + recent series) and dynamic symbol selection.
* **Global loading and error UI**: `app/loading.tsx` and `app/error.tsx` provide default fallback UIs when server components are suspending or erroring.
* **Data update script**: `scripts/daily_update.ts` fetches & caches daily data (equities, crypto, FRED). Includes skipâ€‘logic (timezone aware) and derives summaries from series to minimize external API calls.
* **Tests** using Jest and React Testing Library.
* **Development tooling**: ESLint, Prettier, Husky hooks with lintâ€‘staged, strict TS configuration.  Lint and unit tests run automatically on preâ€‘commit.
* **Environment configuration**: `.env.example` lists required environment variables (e.g. `ALPHAVANTAGE_API_KEY`, optional `OPENAI_API_KEY`, timezone). Secrets are never committed.

Real data fetching for SPY / QQQ / Bitcoin and FRED (e.g. DGS10) is implemented via provider modules (`src/lib/providers/*`). The `data.ts` layer supports a `summaries.json` fallback (generated by the snapshot script) with a live API fallback when stale. Index weighting utilities (`src/lib/indexMath.ts`) and math helpers enable composite series construction.

## Style Guide (Design System)

The project includes a living style guide at `/style-guide` that documents:

* Brand & semantic palette (primary, secondary, success, error, warning, info, neutral, outline)
* Timeâ€‘series / data visualization color mapping (SPY, QQQ, BTC, Rate, Composite Index)
* Typography scale (H1â€“H6, subtitle, body variants) tuned for Korean readability ("Noto Sans KR")
* Component primitives (Buttons, Chips) with usage rules (CTA, status, neutral)
* Spacing (8px base), elevation (shadows 0â€“24), shape (radius: base 12, card 16, pill 999)
* Usage guidelines for when to select each color & variant

When adding a new UI component or page:
1. Conform to existing tokens instead of hardâ€‘coding colors.
2. If a new semantic color is truly needed, add it to `theme.ts` with documentation, then surface it in the style guide page.
3. Update this README and `docs/tasks.md` if JSON structure or global tokens change.

## Vibe Coding Principles

Vibe coding is a methodology for building software together with large language models.  Key principles include:

1. **Problemâ€‘first**: Define what you need to build in natural languageâ€”including requirements, constraints, evaluation criteria, and examplesâ€”before generating any code.
2. **Iterative loops**: Work in small increments.  Generate a skeleton, run it, inspect logs/errors, and refine your prompt.  Keep loops to 5â€“15Â minutes.
3. **Hard constraints**: Specify nonâ€‘negotiable requirements in your prompts (e.g. use Next.jsÂ 15, TypeScript strict mode, MUI components, JSON time series only, KST timezone).
4. **Tests first**: Ask the LLM to write unit tests and sample data alongside implementation.  Use tests as acceptance criteria.
5. **Observability**: Log requests, responses, token usage, and model versions.  Always inspect the raw output.  See `src/lib/logger.ts` for stubs.
6. **Humanâ€‘inâ€‘theâ€‘loop**: Never trust generated code blindly.  Read it, run it, ask why it works, and adjust prompts accordingly.
7. **Refactor before release**: LLMâ€‘generated code should be refactored, optimized, and reviewed by humans before being shipped to production.

A more detailed guide can be found in `docs/vibe_coding_guide.md`.

## Project Structure

```
Statbase/
â”œâ”€â”€ README.md              â€” This file
â”œâ”€â”€ package.json           â€” NPM package manifest (dependencies & scripts)
â”œâ”€â”€ next.config.js         â€” Next.js configuration
â”œâ”€â”€ tsconfig.json          â€” TypeScript compiler configuration
â”œâ”€â”€ .eslintrc.js           â€” ESLint configuration
â”œâ”€â”€ .prettierrc            â€” Prettier formatting rules
â”œâ”€â”€ .husky/                â€” Git hooks (preâ€‘commit runs lint & tests)
â”œâ”€â”€ .gitignore             â€” Ignore generated files (node_modules, .next, etc.)
â”œâ”€â”€ .env.example           â€” Example environment variables
â”œâ”€â”€ app/                   â€” Next.js app directory (pages and layouts)
â”‚   â”œâ”€â”€ layout.tsx         â€” Root layout using `ThemeRegistry` to inject the MUI theme
â”‚   â”œâ”€â”€ loading.tsx        â€” Fallback while server components load
â”‚   â”œâ”€â”€ error.tsx          â€” Error boundary fallback when a route throws
â”‚   â”œâ”€â”€ page.tsx           â€” Dashboard page with search bar & widgets
â”‚   â”œâ”€â”€ builder/page.tsx   â€” Custom index builder page
â”‚   â”œâ”€â”€ reports/page.tsx   â€” Reports index/list page
â”‚   â”œâ”€â”€ api/               â€” API routes for server functions
â”‚   â”‚   â””â”€â”€ report/route.ts â€” Streaming endpoint that calls the OpenAI API
â”‚   â””â”€â”€ settings/page.tsx  â€” Settings page
â”œâ”€â”€ src/                   â€” Clientâ€‘side source code
â”‚   â”œâ”€â”€ components/        â€” Reusable React components
â”‚   â”‚   â”œâ”€â”€ AppShell.tsx
â”‚   â”‚   â”œâ”€â”€ SearchBar.tsx
â”‚   â”‚   â”œâ”€â”€ SummaryCard.tsx
â”‚   â”‚   â”œâ”€â”€ ChartView.tsx    â€” Multiâ€‘line chart based on Recharts
â”‚   â”‚   â”œâ”€â”€ ReportLayout.tsx
â”‚   â”‚   â”œâ”€â”€ SmallTalkChat.tsx
â”‚   â”‚   â””â”€â”€ IndexBuilder.tsx
â”‚   â”œâ”€â”€ lib/               â€” Utility libraries
â”‚   â”‚   â”œâ”€â”€ data.ts        â€” Data helpers (summaries fallback + live fetch)
â”‚   â”‚   â”œâ”€â”€ logger.ts      â€” Structured JSON logger (level, ts, usage)
â”‚   â”‚   â”œâ”€â”€ indexMath.ts   â€” Weighted index composition & return calc
â”‚   â”‚   â””â”€â”€ prompts.ts     â€” Helper to load prompt templates
â”‚   â”œâ”€â”€ theme/             â€” MaterialÂ UI theme configuration
â”‚   â”‚   â”œâ”€â”€ theme.ts       â€” Default MUI theme definition
â”‚   â”‚   â””â”€â”€ ThemeRegistry.tsx â€” Client component that wraps children with `CacheProvider` and `ThemeProvider`
â”‚   â””â”€â”€ types/             â€” Shared TypeScript types (add as needed)
â”œâ”€â”€ prompts/               â€” LLM prompt templates & evaluations
â”‚   â”œâ”€â”€ system_report.md   â€” System prompt for generating macroeconomic reports
â”‚   â”œâ”€â”€ user_report.md     â€” User prompt template with variables
â”‚   â””â”€â”€ evaluation.md      â€” Mini evaluation tasks & expected outputs
â”œâ”€â”€ scripts/               â€” Node scripts for development and data fetching
â”‚   â””â”€â”€ daily_update.ts    â€” Example script for fetching/caching daily EOD data
â”œâ”€â”€ tests/                 â€” Unit and integration tests
â”‚   â”œâ”€â”€ jest.setup.ts
â”‚   â”œâ”€â”€ jest.config.js
â”‚   â”œâ”€â”€ example.test.tsx
â”‚   â””â”€â”€ fixtures/          â€” Sample data for tests
â””â”€â”€ docs/
    â””â”€â”€ vibe_coding_guide.md â€” Inâ€‘depth explanation of vibe coding methodology
```

## Getting Started

1. **Install dependencies** (requires NodeÂ 20+ and npm or pnpm):

   ```bash
   pnpm install
   # or
   npm install
   ```

2. **Set environment variables**:

   Copy `.env.example` to `.env.local` and fill in the required values:

   ```bash
   cp .env.example .env.local
   # edit the file and add your OPENAI_API_KEY and other variables
   ```

3. **Generate (or refresh) local data (optional first run)**:

   ```bash
   npm run update
   ```

   This creates `public/data/*` JSON (equities, crypto, fred, summaries). If skipped, the app will fallback to onâ€‘demand API calls (within rate limits).

4. **Run the development server**:

   ```bash
   pnpm dev
   # or
   npm run dev
   ```

   Open http://localhost:3000 to see the app.  The page will reload when you edit files.

5. **Run tests**:

   ```bash
   pnpm test
   # or
   npm run test
   ```

## Contributing

Follow vibe coding principles: write your problem/intent in plain language, specify constraints, generate a scaffold, review it manually, write tests, then iterate.  Use Git commit hooks to ensure code quality; Husky is configured to run `lint` and `test` before each commit.

---

## Iteration & Tasks Workflow

This project maintains a living execution plan in `docs/tasks.md` (Sets Aâ€“D). When implementing a step:
1. Update the relevant section status (âœ… / ğŸŸ¡ / â³) as soon as code + tests land.
2. For structural JSON changes, update both `README.md` (usage) and `tasks.md` (acceptance criteria) in the same commit.
3. Add new metrics or logs under a versioned filename (e.g. `metrics/openai-usage-YYYY-MM-DD.jsonl`).
4. Keep DATA_CONTEXT raw size < 2KB; trim oldest entries or columns if exceeded.

## Security & Secrets
Run a secret scan before pushing public branches:
```bash
trufflehog git file://. --since-commit=$(git rev-list --max-parents=0 HEAD)
git log -p | grep -E 'sk-[A-Za-z0-9]'
git secrets --scan
```
If a key leaks: revoke, rotate, and document the action in `docs/tasks.md` Change Log.

---
> **NOTE:** Some advanced features (index builder UI validation, extended FRED set, production deployment artifacts) are still in progress; consult `docs/tasks.md` for current status.