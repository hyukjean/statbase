# Statbase

## Overview

Statbase is an AI‑powered macroeconomic analysis web application built with **Next.js 15** and **TypeScript** using **Material Design 3 (MUI)**.  It leverages daily end‑of‑day (EOD) price data from FRED (macroeconomic and rates), Alpha Vantage (US equities), and CoinGecko (cryptocurrency) refreshed via a snapshot script (scheduled for 00:05 KST).  Users can ask natural language questions (e.g. "애플과 금의 가격 움직임을 비교해줘"), view market summaries (SPY / QQQ / Bitcoin), build custom indices (planned), and generate AI‑assisted reports grounded on recent time series.

This repository provides a pre‑configured scaffold tailored for **바이브코딩** (vibe coding).  Vibe coding emphasizes natural‑language prompts, small iterative loops, strict constraints, test‑driven development, and human‑in‑the‑loop evaluation.  Use this scaffold as a starting point in VSCode Copilot or any LLM‑assisted IDE.

## Features

* **Next.js 15 + TypeScript** with the new app router.  Pages live under `/app`.
* **Material 3 (MUI)** theme with customized tokens in `src/theme` (brand palette, series colors, typography scale, elevation, shape). Theme state is provided via a `ThemeRegistry` wrapper using Emotion cache and MUI’s `ThemeProvider`.
* **AppShell** layout with top app bar and navigation drawer.
* **Dashboard**, **Builder**, **Reports**, **Settings**, and **Style Guide** pages.  Each page integrates **loading** and **error** boundaries for improved UX.
* **Components** for search, summary cards, multi‑line charts (Recharts), report layouts, small talk chat, and an evolving Index Builder.
* **Prompts** folder storing LLM prompt templates and evaluation tasks, used by the streaming report API.
* **Streaming report API**: Server route `app/api/report/route.ts` with data grounding (summaries + recent series) and dynamic symbol selection.
* **Global loading and error UI**: `app/loading.tsx` and `app/error.tsx` provide default fallback UIs when server components are suspending or erroring.
* **Data update script**: `scripts/daily_update.ts` fetches & caches daily data (equities, crypto, FRED). Includes skip‑logic (timezone aware) and derives summaries from series to minimize external API calls.
* **Tests** using Jest and React Testing Library.
* **Development tooling**: ESLint, Prettier, Husky hooks with lint‑staged, strict TS configuration.  Lint and unit tests run automatically on pre‑commit.
* **Environment configuration**: `.env.example` lists required environment variables (e.g. `ALPHAVANTAGE_API_KEY`, optional `OPENAI_API_KEY`, timezone). Secrets are never committed.

Real data fetching for SPY / QQQ / Bitcoin and FRED (e.g. DGS10) is implemented via provider modules (`src/lib/providers/*`). The `data.ts` layer supports a `summaries.json` fallback (generated by the snapshot script) with a live API fallback when stale. Index weighting utilities (`src/lib/indexMath.ts`) and math helpers enable composite series construction.

## Style Guide (Design System)

The project includes a living style guide at `/style-guide` that documents:

* Brand & semantic palette (primary, secondary, success, error, warning, info, neutral, outline)
* Time‑series / data visualization color mapping (SPY, QQQ, BTC, Rate, Composite Index)
* Typography scale (H1–H6, subtitle, body variants) tuned for Korean readability ("Noto Sans KR")
* Component primitives (Buttons, Chips) with usage rules (CTA, status, neutral)
* Spacing (8px base), elevation (shadows 0–24), shape (radius: base 12, card 16, pill 999)
* Usage guidelines for when to select each color & variant

When adding a new UI component or page:
1. Conform to existing tokens instead of hard‑coding colors.
2. If a new semantic color is truly needed, add it to `theme.ts` with documentation, then surface it in the style guide page.
3. Update this README and `docs/tasks.md` if JSON structure or global tokens change.

## Vibe Coding Principles

Vibe coding is a methodology for building software together with large language models.  Key principles include:

1. **Problem‑first**: Define what you need to build in natural language—including requirements, constraints, evaluation criteria, and examples—before generating any code.
2. **Iterative loops**: Work in small increments.  Generate a skeleton, run it, inspect logs/errors, and refine your prompt.  Keep loops to 5–15 minutes.
3. **Hard constraints**: Specify non‑negotiable requirements in your prompts (e.g. use Next.js 15, TypeScript strict mode, MUI components, JSON time series only, KST timezone).
4. **Tests first**: Ask the LLM to write unit tests and sample data alongside implementation.  Use tests as acceptance criteria.
5. **Observability**: Log requests, responses, token usage, and model versions.  Always inspect the raw output.  See `src/lib/logger.ts` for stubs.
6. **Human‑in‑the‑loop**: Never trust generated code blindly.  Read it, run it, ask why it works, and adjust prompts accordingly.
7. **Refactor before release**: LLM‑generated code should be refactored, optimized, and reviewed by humans before being shipped to production.

A more detailed guide can be found in `docs/vibe_coding_guide.md`.

## Project Structure

```
Statbase/
├── README.md              — This file
├── package.json           — NPM package manifest (dependencies & scripts)
├── next.config.js         — Next.js configuration
├── tsconfig.json          — TypeScript compiler configuration
├── .eslintrc.js           — ESLint configuration
├── .prettierrc            — Prettier formatting rules
├── .husky/                — Git hooks (pre‑commit runs lint & tests)
├── .gitignore             — Ignore generated files (node_modules, .next, etc.)
├── .env.example           — Example environment variables
├── app/                   — Next.js app directory (pages and layouts)
│   ├── layout.tsx         — Root layout using `ThemeRegistry` to inject the MUI theme
│   ├── loading.tsx        — Fallback while server components load
│   ├── error.tsx          — Error boundary fallback when a route throws
│   ├── page.tsx           — Dashboard page with search bar & widgets
│   ├── builder/page.tsx   — Custom index builder page
│   ├── reports/page.tsx   — Reports index/list page
│   ├── api/               — API routes for server functions
│   │   └── report/route.ts — Streaming endpoint that calls the OpenAI API
│   └── settings/page.tsx  — Settings page
├── src/                   — Client‑side source code
│   ├── components/        — Reusable React components
│   │   ├── AppShell.tsx
│   │   ├── SearchBar.tsx
│   │   ├── SummaryCard.tsx
│   │   ├── ChartView.tsx    — Multi‑line chart based on Recharts
│   │   ├── ReportLayout.tsx
│   │   ├── SmallTalkChat.tsx
│   │   └── IndexBuilder.tsx
│   ├── lib/               — Utility libraries
│   │   ├── data.ts        — Data helpers (summaries fallback + live fetch)
│   │   ├── logger.ts      — Structured JSON logger (level, ts, usage)
│   │   ├── indexMath.ts   — Weighted index composition & return calc
│   │   └── prompts.ts     — Helper to load prompt templates
│   ├── theme/             — Material UI theme configuration
│   │   ├── theme.ts       — Default MUI theme definition
│   │   └── ThemeRegistry.tsx — Client component that wraps children with `CacheProvider` and `ThemeProvider`
│   └── types/             — Shared TypeScript types (add as needed)
├── prompts/               — LLM prompt templates & evaluations
│   ├── system_report.md   — System prompt for generating macroeconomic reports
│   ├── user_report.md     — User prompt template with variables
│   └── evaluation.md      — Mini evaluation tasks & expected outputs
├── scripts/               — Node scripts for development and data fetching
│   └── daily_update.ts    — Example script for fetching/caching daily EOD data
├── tests/                 — Unit and integration tests
│   ├── jest.setup.ts
│   ├── jest.config.js
│   ├── example.test.tsx
│   └── fixtures/          — Sample data for tests
└── docs/
    └── vibe_coding_guide.md — In‑depth explanation of vibe coding methodology
```

## Getting Started

1. **Install dependencies** (requires Node 20+ and npm or pnpm):

   ```bash
   pnpm install
   # or
   npm install
   ```

2. **Set environment variables**:

   Copy `.env.example` to `.env.local` and fill in the required values:

   ```bash
   cp .env.example .env.local
   # edit the file and add your OPENAI_API_KEY and other variables
   ```

3. **Generate (or refresh) local data (optional first run)**:

   ```bash
   npm run update
   ```

   This creates `public/data/*` JSON (equities, crypto, fred, summaries). If skipped, the app will fallback to on‑demand API calls (within rate limits).

4. **Run the development server**:

   ```bash
   pnpm dev
   # or
   npm run dev
   ```

   Open http://localhost:3000 to see the app.  The page will reload when you edit files.

5. **Run tests**:

   ```bash
   pnpm test
   # or
   npm run test
   ```

## Contributing

Follow vibe coding principles: write your problem/intent in plain language, specify constraints, generate a scaffold, review it manually, write tests, then iterate.  Use Git commit hooks to ensure code quality; Husky is configured to run `lint` and `test` before each commit.

---

## Iteration & Tasks Workflow

This project maintains a living execution plan in `docs/tasks.md` (Sets A–D). When implementing a step:
1. Update the relevant section status (✅ / 🟡 / ⏳) as soon as code + tests land.
2. For structural JSON changes, update both `README.md` (usage) and `tasks.md` (acceptance criteria) in the same commit.
3. Add new metrics or logs under a versioned filename (e.g. `metrics/openai-usage-YYYY-MM-DD.jsonl`).
4. Keep DATA_CONTEXT raw size < 2KB; trim oldest entries or columns if exceeded.

## Security & Secrets
Run a secret scan before pushing public branches:
```bash
trufflehog git file://. --since-commit=$(git rev-list --max-parents=0 HEAD)
git log -p | grep -E 'sk-[A-Za-z0-9]'
git secrets --scan
```
If a key leaks: revoke, rotate, and document the action in `docs/tasks.md` Change Log.

---
> **NOTE:** Some advanced features (index builder UI validation, extended FRED set, production deployment artifacts) are still in progress; consult `docs/tasks.md` for current status.